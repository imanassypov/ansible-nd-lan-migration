---
#==============================================================================
# Playbook: Configure Interfaces in Nexus Dashboard Fabric Controller (NDFC)
#==============================================================================
# Purpose: Deploy Layer 2 and VPC interface configurations to NDFC
#          for the target fabric using profiled interface inventory data
#
# Prerequisites:
#   - Interface inventory files generated by 1.0-profile-existing-switches.yml
#   - NDFC fabric must already be created and switches added
#   - VPC domains must be configured (for VPC interface deployment)
#
# Inventory Files Used:
#   - fabrics/<fabric>/l2_interfaces.yml - Non-VPC L2 interface configurations
#   - fabrics/<fabric>/l2_vpc_interfaces.yml - VPC interface configurations (consolidated by vpc_id)
#
# Tags:
#   - deploy-l2-interfaces: Deploy only Layer 2 interfaces
#   - deploy-vpc-interfaces: Deploy only VPC interfaces
#
# Usage Examples:
#   ansible-playbook 1.2-provision-interfaces.yml --tags deploy-l2-interfaces
#   ansible-playbook 1.2-provision-interfaces.yml --tags deploy-vpc-interfaces
#   ansible-playbook 1.2-provision-interfaces.yml  # Deploy all interface types
#==============================================================================

#------------------------------------------------------------------------------
# Play 1: Configure Layer 2 Interfaces
#------------------------------------------------------------------------------
# Deploys non-VPC Layer 2 interface configurations including:
#   - Access ports with VLAN assignments
#   - Trunk ports with allowed VLANs and native VLAN
#   - Port-channels (non-VPC)
# 
# Note: VPC interfaces are deployed separately in Play 2
#------------------------------------------------------------------------------
- name: Configure Layer 2 Interfaces in NDFC
  hosts: nexus_dashboard
  gather_facts: false
  tags: deploy-l2-interfaces

  tasks:
    # Build list of switches to provision
    - name: Build list of switches to provision
      ansible.builtin.set_fact:
        switches_to_provision: >-
          {{
            groups['switches'] | default([])
            | map('extract', hostvars)
            | selectattr('add_to_fabric', 'defined')
            | selectattr('add_to_fabric', 'equalto', true)
            | list
          }}

    # Load L2 interfaces from all fabrics
    - name: Find all l2_interfaces.yml files
      ansible.builtin.find:
        paths: "{{ playbook_dir }}/../../fabrics"
        patterns: "l2_interfaces.yml"
        recurse: true
      register: l2_interfaces_files
      when: switches_to_provision | length > 0

    - name: Load L2 interfaces data from all fabrics
      ansible.builtin.include_vars:
        file: "{{ item.path }}"
        name: "l2_data_{{ item.path | dirname | basename }}"
      loop: "{{ l2_interfaces_files.files | default([]) }}"
      loop_control:
        label: "{{ item.path | dirname | basename }}"
      when: switches_to_provision | length > 0

    # Build consolidated L2 interfaces lookup
    - name: Build consolidated L2 interfaces lookup
      ansible.builtin.set_fact:
        l2_interfaces_lookup: |
          {%- set lookup = {} -%}
          {%- for file in l2_interfaces_files.files | default([]) -%}
            {%- set fabric_name = file.path | dirname | basename -%}
            {%- set var_name = 'l2_data_' + fabric_name -%}
            {%- if hostvars[inventory_hostname][var_name] is defined -%}
              {%- set fabric_data = hostvars[inventory_hostname][var_name] -%}
              {%- if fabric_data.switches is defined -%}
                {%- for hostname, data in fabric_data.switches.items() -%}
                  {%- set _ = lookup.update({hostname: {'interfaces': data.interfaces | default([]), 'fabric': fabric_name}}) -%}
                {%- endfor -%}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: switches_to_provision | length > 0

    # Build port-channel member interfaces list (extract members from port-channels)
    - name: Build port-channel member interfaces for each switch
      ansible.builtin.set_fact:
        pc_member_interfaces_lookup: |
          {%- set lookup = {} -%}
          {%- for switch_name in l2_interfaces_lookup.keys() -%}
            {%- set members = [] -%}
            {%- set port_channels = l2_interfaces_lookup[switch_name].interfaces | selectattr('type', 'equalto', 'pc') | list -%}
            {%- for pc in port_channels -%}
              {%- if pc.members is defined -%}
                {%- for member in pc.members -%}
                  {%- set member_iface = {
                    'name': member.interface,
                    'type': 'eth',
                    'mode': 'trunk',
                    'description': '',
                    'trunk': {
                      'allowed_vlans': pc.trunk.allowed_vlans | default('none'),
                      'native_vlan': pc.trunk.native_vlan | default('')
                    }
                  } -%}
                  {%- set _ = members.append(member_iface) -%}
                {%- endfor -%}
              {%- endif -%}
            {%- endfor -%}
            {%- if members | length > 0 -%}
              {%- set _ = lookup.update({switch_name: members}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: switches_to_provision | length > 0

    # Query existing interfaces for each switch
    - name: Query existing interfaces from NDFC
      cisco.nd.nd_rest:
        path: "/appcenter/cisco/ndfc/api/v1/lan-fabric/rest/interface/detail?serialNumber={{ hostvars[item]['destination_switch_sn'] }}"
        method: GET
      loop: "{{ switches_to_provision | map(attribute='inventory_hostname') | list }}"
      loop_control:
        label: "{{ item }}"
      when: switches_to_provision | length > 0
      register: existing_interfaces_query

    # Build set of existing interface names per switch
    - name: Build set of existing interface names per switch
      ansible.builtin.set_fact:
        existing_interfaces_by_switch: |
          {%- set interfaces = {} -%}
          {%- for result in existing_interfaces_query.results | default([]) -%}
            {%- if result.current is defined and result.current is iterable -%}
              {%- set switch_interfaces = [] -%}
              {%- for iface in result.current -%}
                {%- if iface.ifName is defined -%}
                  {%- set _ = switch_interfaces.append(iface.ifName | lower) -%}
                {%- endif -%}
              {%- endfor -%}
              {%- set _ = interfaces.update({result.item: switch_interfaces}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ interfaces }}
      when: existing_interfaces_query is defined

    # Display existing interfaces for debugging
    - name: Display existing interfaces per switch
      ansible.builtin.debug:
        msg: "Switch {{ item.key }} has {{ item.value | length }} existing interfaces: {{ item.value[:5] }}{% if item.value | length > 5 %}... ({{ item.value | length - 5 }} more){% endif %}"
      loop: "{{ existing_interfaces_by_switch | dict2items }}"
      loop_control:
        label: "{{ item.key }}"
      when: existing_interfaces_by_switch is defined

    # Filter port-channel member interfaces to only include non-existing ones
    - name: Filter port-channel member interfaces (exclude existing)
      ansible.builtin.set_fact:
        pc_member_interfaces_filtered: |
          {%- set filtered = {} -%}
          {%- for switch_name, members in pc_member_interfaces_lookup.items() -%}
            {%- set new_members = [] -%}
            {%- for member in members -%}
              {%- if switch_name not in existing_interfaces_by_switch or member.name | lower not in existing_interfaces_by_switch[switch_name] -%}
                {%- set _ = new_members.append(member) -%}
              {%- endif -%}
            {%- endfor -%}
            {%- if new_members | length > 0 -%}
              {%- set _ = filtered.update({switch_name: new_members}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ filtered }}
      when: 
        - pc_member_interfaces_lookup is defined
        - existing_interfaces_by_switch is defined

    # Configure port-channel member Ethernet interfaces first (must exist before port-channel)
    - name: Configure port-channel member Ethernet interfaces for each switch
      cisco.nd.nd_rest:
        path: /appcenter/cisco/ndfc/api/v1/lan-fabric/rest/globalInterface
        method: post
        content: "{{ lookup('template', playbook_dir + '/../../templates/1.4-provision-interfaces.json.j2') }}"
      vars:
        switch_name: "{{ switch.inventory_hostname }}"
        switch_serial: "{{ hostvars[switch.inventory_hostname]['destination_switch_sn'] }}"
        switch_fabric: "{{ hostvars[switch.inventory_hostname]['fabric'] }}"
        switch_interfaces: "{{ pc_member_interfaces_filtered[switch.inventory_hostname] | default([]) }}"
        interface_type: "l2"
      loop: "{{ switches_to_provision }}"
      loop_control:
        loop_var: switch
        label: "{{ switch.inventory_hostname }}"
      when: 
        - switches_to_provision | length > 0
        - switch.inventory_hostname in pc_member_interfaces_filtered
        - pc_member_interfaces_filtered[switch.inventory_hostname] | length > 0
      register: l2_pc_member_deploy_result
      tags: deploy-l2-interfaces

    # Configure standalone Ethernet interfaces (non-port-channel members)
    - name: Configure standalone Ethernet interfaces for each switch
      cisco.nd.nd_rest:
        path: /appcenter/cisco/ndfc/api/v1/lan-fabric/rest/globalInterface
        method: post
        content: "{{ lookup('template', playbook_dir + '/../../templates/1.4-provision-interfaces.json.j2') }}"
      vars:
        switch_name: "{{ switch.inventory_hostname }}"
        switch_serial: "{{ hostvars[switch.inventory_hostname]['destination_switch_sn'] }}"
        switch_fabric: "{{ hostvars[switch.inventory_hostname]['fabric'] }}"
        switch_interfaces: "{{ l2_interfaces_lookup[switch.inventory_hostname].interfaces | selectattr('type', 'equalto', 'eth') | list }}"
        interface_type: "l2"
      loop: "{{ switches_to_provision }}"
      loop_control:
        loop_var: switch
        label: "{{ switch.inventory_hostname }}"
      when: 
        - switches_to_provision | length > 0
        - switch.inventory_hostname in l2_interfaces_lookup
        - l2_interfaces_lookup[switch.inventory_hostname].interfaces | selectattr('type', 'equalto', 'eth') | list | length > 0
      register: l2_eth_deploy_result
      tags: deploy-l2-interfaces

    # Filter port-channel interfaces to only include non-existing ones
    - name: Filter port-channel interfaces (exclude existing)
      ansible.builtin.set_fact:
        pc_interfaces_filtered: |
          {%- set filtered = {} -%}
          {%- for switch_name in l2_interfaces_lookup.keys() -%}
            {%- set port_channels = l2_interfaces_lookup[switch_name].interfaces | selectattr('type', 'equalto', 'pc') | list -%}
            {%- set new_pcs = [] -%}
            {%- for pc in port_channels -%}
              {%- if switch_name not in existing_interfaces_by_switch or pc.name | lower not in existing_interfaces_by_switch[switch_name] -%}
                {%- set _ = new_pcs.append(pc) -%}
              {%- endif -%}
            {%- endfor -%}
            {%- if new_pcs | length > 0 -%}
              {%- set _ = filtered.update({switch_name: new_pcs}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ filtered }}
      when: 
        - l2_interfaces_lookup is defined
        - existing_interfaces_by_switch is defined

    # Configure Port-channel interfaces for each switch (after member interfaces exist)
    - name: Configure Port-channel interfaces for each switch
      cisco.nd.nd_rest:
        path: /appcenter/cisco/ndfc/api/v1/lan-fabric/rest/globalInterface
        method: post
        content: "{{ lookup('template', playbook_dir + '/../../templates/1.4-provision-interfaces.json.j2') }}"
      vars:
        switch_name: "{{ switch.inventory_hostname }}"
        switch_serial: "{{ hostvars[switch.inventory_hostname]['destination_switch_sn'] }}"
        switch_fabric: "{{ hostvars[switch.inventory_hostname]['fabric'] }}"
        switch_interfaces: "{{ pc_interfaces_filtered[switch.inventory_hostname] | default([]) }}"
        interface_type: "l2"
      loop: "{{ switches_to_provision }}"
      loop_control:
        loop_var: switch
        label: "{{ switch.inventory_hostname }}"
      when: 
        - switches_to_provision | length > 0
        - pc_interfaces_filtered is defined
        - switch.inventory_hostname in pc_interfaces_filtered
        - pc_interfaces_filtered[switch.inventory_hostname] | length > 0
      register: l2_pc_deploy_result
      tags: deploy-l2-interfaces

    # Debug port-channel member interface deployment results
    - name: Display port-channel member interface deployment results
      ansible.builtin.debug:
        msg: |
          Switch: {{ item.switch.inventory_hostname }}
          Type: Port-channel Member Ethernet Interfaces
          Status: {{ 'FAILED' if item.failed | default(false) else ('CHANGED' if item.changed else 'OK') }}
          {% if item.failed | default(false) %}
          Error: {{ item.msg | default('Unknown error') }}
          {% endif %}
      loop: "{{ l2_pc_member_deploy_result.results | default([]) }}"
      loop_control:
        label: "{{ item.switch.inventory_hostname }}"
      when: l2_pc_member_deploy_result.results is defined

    # Debug standalone Ethernet interface deployment results
    - name: Display standalone Ethernet interface deployment results
      ansible.builtin.debug:
        msg: |
          Switch: {{ item.switch.inventory_hostname }}
          Type: Standalone Ethernet Interfaces
          Status: {{ 'FAILED' if item.failed | default(false) else ('CHANGED' if item.changed else 'OK') }}
          {% if item.failed | default(false) %}
          Error: {{ item.msg | default('Unknown error') }}
          {% endif %}
      loop: "{{ l2_eth_deploy_result.results | default([]) }}"
      loop_control:
        label: "{{ item.switch.inventory_hostname }}"
      when: l2_eth_deploy_result.results is defined

    # Debug Port-channel deployment results
    - name: Display Port-channel deployment results
      ansible.builtin.debug:
        msg: |
          Switch: {{ item.switch.inventory_hostname }}
          Type: Port-channel Interfaces
          Status: {{ 'FAILED' if item.failed | default(false) else ('CHANGED' if item.changed else 'OK') }}
          {% if item.failed | default(false) %}
          Error: {{ item.msg | default('Unknown error') }}
          {% endif %}
      loop: "{{ l2_pc_deploy_result.results | default([]) }}"
      loop_control:
        label: "{{ item.switch.inventory_hostname }}"
      when: l2_pc_deploy_result.results is defined

#------------------------------------------------------------------------------
# Play 2: Configure VPC Interfaces
#------------------------------------------------------------------------------
# Deploys VPC (Virtual Port Channel) interface configurations
# 
# VPC interfaces are consolidated by vpc_id during profiling, meaning each VPC
# interface spans two switches (peer1 and peer2). This play deploys:
#   - VPC trunk ports with allowed VLANs
#   - VPC access ports
#   - Port-channel members for each peer
#
# Note: VPC domain must be configured before deploying VPC interfaces
#------------------------------------------------------------------------------
- name: Configure VPC Interfaces in NDFC
  hosts: nexus_dashboard
  gather_facts: false
  tags: deploy-vpc-interfaces

  tasks:
    # Build list of switches to provision
    - name: Build list of switches to provision
      ansible.builtin.set_fact:
        switches_to_provision: >-
          {{
            groups['switches'] | default([])
            | map('extract', hostvars)
            | selectattr('add_to_fabric', 'defined')
            | selectattr('add_to_fabric', 'equalto', true)
            | list
          }}

    # Load VPC interfaces from all fabrics
    - name: Find all l2_vpc_interfaces.yml files
      ansible.builtin.find:
        paths: "{{ playbook_dir }}/../../fabrics"
        patterns: "l2_vpc_interfaces.yml"
        recurse: true
      register: vpc_interfaces_files
      when: switches_to_provision | length > 0

    - name: Load VPC interfaces data from all fabrics
      ansible.builtin.include_vars:
        file: "{{ item.path }}"
        name: "vpc_data_{{ item.path | dirname | basename }}"
      loop: "{{ vpc_interfaces_files.files | default([]) }}"
      loop_control:
        label: "{{ item.path | dirname | basename }}"
      when: switches_to_provision | length > 0

    # Build consolidated VPC interfaces lookup (per fabric)
    - name: Build consolidated VPC interfaces lookup
      ansible.builtin.set_fact:
        vpc_interfaces_by_fabric: |
          {%- set lookup = {} -%}
          {%- for file in vpc_interfaces_files.files | default([]) -%}
            {%- set fabric_name = file.path | dirname | basename -%}
            {%- set var_name = 'vpc_data_' + fabric_name -%}
            {%- if hostvars[inventory_hostname][var_name] is defined -%}
              {%- set vpc_data = hostvars[inventory_hostname][var_name] -%}
              {%- if vpc_data.vpc_interfaces is defined -%}
                {%- set _ = lookup.update({fabric_name: vpc_data.vpc_interfaces}) -%}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: switches_to_provision | length > 0

    # Get unique fabrics from switches to provision
    - name: Get unique fabrics from switches to provision
      ansible.builtin.set_fact:
        fabrics_to_process: "{{ switches_to_provision | map(attribute='fabric') | unique | list }}"
      when: switches_to_provision | length > 0

    # Configure VPC interfaces for each fabric using REST API
    - name: Configure VPC interfaces for each fabric
      cisco.nd.nd_rest:
        path: /appcenter/cisco/ndfc/api/v1/lan-fabric/rest/globalInterface
        method: post
        content: "{{ lookup('template', playbook_dir + '/../../templates/1.4-provision-interfaces-vpc.json.j2') }}"
      vars:
        vpc_interface: "{{ vpc_item }}"
        fabric_name: "{{ vpc_item.switches | map('extract', hostvars) | map(attribute='fabric') | first }}"
        peer1_serial: "{{ hostvars[vpc_item.switches[0]]['destination_switch_sn'] }}"
        peer2_serial: "{{ hostvars[vpc_item.switches[1]]['destination_switch_sn'] }}"
      loop: "{{ fabrics_to_process | default([]) | map('extract', vpc_interfaces_by_fabric) | flatten }}"
      loop_control:
        loop_var: vpc_item
        label: "VPC {{ vpc_item.vpc_id }}: {{ vpc_item.name }}"
      when: 
        - switches_to_provision | length > 0
        - fabrics_to_process is defined
        - vpc_interfaces_by_fabric is defined
        - vpc_item.switches | intersect(switches_to_provision | map(attribute='inventory_hostname') | list) | length > 0
      register: vpc_deploy_result